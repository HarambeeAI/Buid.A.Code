# Progress Log

## Learnings
(Patterns discovered during implementation)

- Prisma 7.x uses a new config format: datasource URL goes in prisma.config.ts, not in schema.prisma
- Use `prisma-client-js` as the generator provider (not `prisma-client`)
- Prisma validate and generate work without a running database - good for CI/CD
- Use `prisma migrate diff --from-empty --to-schema ./prisma/schema.prisma --script` to preview migration SQL

---

## Iteration 1 - US-001: Core Schema - User, Project, Folder
- What was implemented:
  - Next.js 14+ project with TypeScript and Tailwind CSS
  - Prisma schema with User, Project, Folder models
  - User model: UUID id, logto_user_id (unique), email, name, tier (FREE/PRO default FREE), analyses_remaining (default 2, nullable), role (USER/ADMIN default USER), timestamps
  - Folder model: user_id FK with cascade delete
  - Project model: user_id FK with cascade delete, folder_id FK with SET NULL on delete
  - Migration SQL file ready for Railway PostgreSQL
  - Prisma client helper in src/lib/prisma.ts
- Files changed:
  - app/prisma/schema.prisma (new)
  - app/prisma/migrations/0001_init/migration.sql (new)
  - app/src/lib/prisma.ts (new)
  - app/prisma.config.ts (modified for Prisma 7)
  - app/.env.example (new)
- Learnings for future iterations:
  - Project is inside /app subdirectory due to npm naming restrictions
  - TypeScript check: `npx tsc --noEmit`
  - Prisma validation: `npx prisma validate`
  - Migration preview: `npx prisma migrate diff --from-empty --to-schema ./prisma/schema.prisma --script`
---

## Iteration 2 - US-002: Schema - Analysis
- What was implemented:
  - Added Analysis model to Prisma schema with all required fields
  - Added enums: Region (AU/UK/US), DocumentType (PDF/PNG/JPG/TIFF/DXF/IFC), AnalysisStatus (7 states), OverallStatus (PASS/CONDITIONAL/FAIL)
  - Analysis fields: id (UUID), project_id (FK), report_ref (unique), document_name, document_url, document_size, document_type, page_count, description (nullable), page_numbers (nullable), region, selected_codes (JSON), status, current_stage (nullable), compliance_score (nullable), overall_status (nullable), count fields (all default 0), timestamps
  - Cascade delete: Project -> Analyses
  - Created migration SQL file
- Files changed:
  - app/prisma/schema.prisma (modified - added enums and Analysis model)
  - app/prisma/migrations/0002_analysis/migration.sql (new)
- Learnings for future iterations:
  - Each migration folder needs its own migration.sql file
  - Prisma generate must be run after schema changes to update the client
  - The analyses relation was added to the Project model for cascade functionality
---

## Iteration 3 - US-003: Schema - Finding
- What was implemented:
  - Added Finding model to Prisma schema with all required fields
  - Added enums: FindingCategory (10 values: STRUCTURAL, FIRE_SAFETY, EGRESS, ACCESSIBILITY, ENERGY, GENERAL_BUILDING, SITE, PLUMBING, ELECTRICAL, MECHANICAL), FindingStatus (4 values: COMPLIANT, WARNING, CRITICAL, NOT_ASSESSED), Confidence (HIGH, MEDIUM, LOW)
  - Finding fields: id (UUID), analysis_id (FK), code_reference, category, status, confidence, description, required_value, proposed_value (nullable), page_number (nullable), location (nullable), analysis_notes, recommendation (nullable), raw_extraction (JSON nullable), sort_order
  - Cascade delete: Analysis -> Findings
  - Composite index on (analysis_id, sort_order) for efficient querying
  - Created migration SQL file
- Files changed:
  - app/prisma/schema.prisma (modified - added enums and Finding model, added findings relation to Analysis)
  - app/prisma/migrations/0003_finding/migration.sql (new)
- Learnings for future iterations:
  - When adding a new model with a relation, update both sides (Finding model + findings[] on Analysis)
  - Composite indexes use @@index([field1, field2]) syntax in Prisma
---

## Iteration 4 - US-004: Schema - BuildingCode and CodeRequirement
- What was implemented:
  - Added BuildingCode model with all required fields: id (UUID), region (FK to Region enum), code_id (unique), name, description (nullable), version, status (BuildingCodeStatus enum: DRAFT/ACTIVE/DEPRECATED), source_document_url (nullable), published_at (nullable), published_by (nullable FK to User), created_at
  - Added CodeRequirement model with complete schema: id (UUID), building_code_id (FK), code_ref, title, category (FindingCategory enum), full_text, check_type (CheckType enum), thresholds (JSON), applies_to_drawing_types (JSON), applies_to_building_types (JSON), applies_to_spaces (JSON), exceptions (JSON), extraction_guidance (Text), evaluation_guidance (Text), source_page (nullable), status (CodeRequirementStatus enum: DRAFT/VERIFIED/PUBLISHED/DEPRECATED), embedding (vector 768 via pgvector), timestamps
  - Added enums: BuildingCodeStatus, CodeRequirementStatus, CheckType
  - Enabled pgvector extension for embedding support
  - Cascade delete: BuildingCode -> CodeRequirements
  - Added publishedCodes relation on User model for published_by FK
- Files changed:
  - app/prisma/schema.prisma (modified - added enums, BuildingCode, CodeRequirement models)
  - app/prisma/migrations/0004_building_code_and_requirement/migration.sql (new)
- Learnings for future iterations:
  - pgvector requires `CREATE EXTENSION IF NOT EXISTS vector;` in migration SQL
  - Use `Unsupported("vector(768)")` in Prisma schema for pgvector types
  - When adding a FK relation like published_by, add the reverse relation on the parent model (User.publishedCodes)
---

## Iteration 5 - US-005: Schema - CodeRequest and ShareToken
- What was implemented:
  - Added CodeRequest model with all required fields: id (UUID), user_id (FK to User), code_name, region (Region enum), description (nullable), reference_url (nullable), status (CodeRequestStatus enum: SUBMITTED/UNDER_REVIEW/IN_PROGRESS/PUBLISHED/DECLINED), admin_notes (nullable), resolved_code_id (nullable FK to BuildingCode), timestamps
  - Added ShareToken model: id (UUID), analysis_id (FK to Analysis), token (unique), is_active (default true), created_at
  - Added CodeRequestStatus enum with 5 values
  - Cascade delete: User -> CodeRequests, Analysis -> ShareTokens
  - SetNull on delete for resolved_code_id FK
  - Added codeRequests relation on User model
  - Added shareTokens relation on Analysis model
  - Added resolvedCodeRequests relation on BuildingCode model
  - Created migration SQL file
- Files changed:
  - app/prisma/schema.prisma (modified - added enum, CodeRequest, ShareToken models, updated relations)
  - app/prisma/migrations/0005_code_request_and_share_token/migration.sql (new)
- Learnings for future iterations:
  - When adding FK relations with nullable references, use SetNull on delete behavior
  - Remember to add reverse relations on all referenced models (User.codeRequests, Analysis.shareTokens, BuildingCode.resolvedCodeRequests)
---

## Iteration 6 - US-006: Seed Data - Building Codes and Sample Requirements
- What was implemented:
  - Created prisma/seed.ts with complete seed data
  - 8 BuildingCode records: AU (5: NCC-2022, AS-SI-01, AS-SI-02, AS-SI-03, AS-BP-01), UK (1: UK-BR-2010), US (2: IRC-2021, IBC-2021) - all ACTIVE status
  - 12 CodeRequirement records for IRC 2021 across categories (STRUCTURAL, FIRE_SAFETY, EGRESS, ACCESSIBILITY, ENERGY, GENERAL_BUILDING, PLUMBING) - all PUBLISHED status
  - Each CodeRequirement has complete fields including extraction_guidance and evaluation_guidance
  - Uses upsert to handle re-running the seed safely
  - Added tsx dev dependency for running TypeScript seeds
  - Added prisma.seed configuration to package.json
- Files changed:
  - app/prisma/seed.ts (new)
  - app/package.json (modified - added seed script and tsx dependency)
- Learnings for future iterations:
  - Use upsert with stable UUIDs for deterministic seeding
  - Prisma seed config goes in package.json under "prisma": { "seed": "..." }
  - tsx is needed to run TypeScript seeds: `npx tsx prisma/seed.ts`
  - Run with `npx prisma db seed` or `npm run db:seed`
---

## Iteration 7 - US-007: Logto Auth - Login / Callback / Logout
- What was implemented:
  - Logto Next.js SDK integration using edge runtime for App Router compatibility
  - GET /api/auth/login - redirects to Logto OIDC authorization endpoint
  - GET /api/auth/callback - handles OAuth callback, exchanges code for tokens, sets session cookie
  - POST /api/auth/logout - clears session and signs out user
  - Auth utility functions: getSession(), requireAuth(), unauthorized(), forbidden()
  - Logto client configuration via environment variables
  - Updated .env.example with Logto environment variables
- Files changed:
  - app/src/lib/logto.ts (new) - Logto client configuration
  - app/src/lib/auth.ts (new) - Auth helper functions
  - app/src/app/api/auth/login/route.ts (new) - Login endpoint
  - app/src/app/api/auth/callback/route.ts (new) - OAuth callback endpoint
  - app/src/app/api/auth/logout/route.ts (new) - Logout endpoint
  - app/.env.example (modified) - Added Logto env vars
  - app/package.json (modified) - Added @logto/next and jose dependencies
- Learnings for future iterations:
  - Use `@logto/next/edge` import for App Router edge runtime compatibility
  - Logto SDK v4.x has separate exports for Pages Router (default), Edge, and Server Actions
  - Cookie handling is built into Logto SDK - uses httpOnly, Secure, SameSite=Lax
  - The `getLogtoContext()` method provides both auth status and claims in one call
---

## Iteration 8 - US-008: Logto Webhook - User Sync
- What was implemented:
  - POST /api/webhooks/logto endpoint for handling Logto webhook events
  - HMAC-SHA256 signature validation using `logto-signature-sha-256` header
  - User.Created event handling: creates user with tier=FREE, analyses_remaining=2, role=USER
  - Uses upsert to handle duplicate user creation gracefully (updates email/name if user exists)
  - Added LOGTO_WEBHOOK_SIGNING_KEY to .env.example
- Files changed:
  - app/src/app/api/webhooks/logto/route.ts (new) - Webhook handler
  - app/.env.example (modified) - Added LOGTO_WEBHOOK_SIGNING_KEY
- Learnings for future iterations:
  - Logto webhooks use `logto-signature-sha-256` header for HMAC signature
  - Event names are PascalCase (e.g., "User.Created" not "user.created")
  - Always use upsert for webhook handlers to handle duplicate deliveries
  - Get raw body with `request.text()` before parsing JSON for signature verification
---

## Iteration 9 - US-009: GET /api/auth/me
- What was implemented:
  - GET /api/auth/me endpoint for fetching authenticated user profile
  - Validates JWT via Logto session using existing requireAuth() helper
  - Fetches user from database using logto_user_id from session
  - Returns { id, email, name, tier, analyses_remaining, role }
  - Returns 401 if not authenticated, 404 if user not in database
- Files changed:
  - app/src/app/api/auth/me/route.ts (new) - User profile endpoint
  - PRD.md (modified) - Marked US-009 complete
- Learnings for future iterations:
  - The existing auth.ts requireAuth() pattern works well for API routes
  - Use Prisma select to return only needed fields for security and performance
  - Logto session userId maps to logto_user_id in our User model
---

## Iteration 10 - US-010: Project CRUD
- What was implemented:
  - POST /api/projects - creates project with name, description, folder_id (optional)
  - GET /api/projects - lists projects with pagination (page, limit params), includes analysis_count
  - GET /api/projects/:id - returns project detail, 403 if not owner
  - PATCH /api/projects/:id - updates project fields, 403 if not owner
  - DELETE /api/projects/:id - deletes project with cascade to analyses
  - All endpoints require authentication (401 if not authenticated)
  - Folder ownership validated when assigning folder_id
  - Zod validation for all inputs
- Files changed:
  - app/src/app/api/projects/route.ts (new) - POST and GET list endpoints
  - app/src/app/api/projects/[id]/route.ts (new) - GET detail, PATCH, DELETE endpoints
- Learnings for future iterations:
  - Use zod's `.issues[0].message` not `.errors[0].message` for error messages
  - Next.js 15+ dynamic route params are async: use `await context.params`
  - Transform Prisma `_count` relations to flat fields for cleaner API responses
  - Use `z.coerce.number()` for query params that come as strings
---

## Iteration 11 - US-011: Folder CRUD
- What was implemented:
  - POST /api/folders - creates a folder with name, returns folder with id, name, created_at
  - GET /api/folders - lists all folders for user with project_count, ordered by name
  - PATCH /api/folders/:id - renames a folder, 403 if not owner
  - DELETE /api/folders/:id - sets folder_id to null on projects in folder, then deletes folder (via transaction)
  - All endpoints require authentication (401 if not authenticated)
  - Zod validation for all inputs
- Files changed:
  - app/src/app/api/folders/route.ts (new) - POST and GET list endpoints
  - app/src/app/api/folders/[id]/route.ts (new) - PATCH and DELETE endpoints
- Learnings for future iterations:
  - Use Prisma $transaction for operations that need atomicity (e.g., update projects then delete folder)
  - Folder delete uses SetNull behavior defined in schema, but explicit updateMany + delete in transaction is safer for clarity
---

## Iteration 12 - US-012: Analysis Creation with Tier Validation
- What was implemented:
  - POST /api/projects/:pid/analyses - creates analysis with tier-based validation
  - GET /api/projects/:pid/analyses - lists analyses for a project with pagination
  - Generates unique report_ref in BAC-YYYY-NNNNN format (timestamp + random for uniqueness)
  - FREE tier validation: page_count <= 5, codes <= 3, analyses_remaining > 0
  - FREE tier: decrements analyses_remaining on successful creation using transaction
  - PRO tier validation: page_count <= 50, no code limit
  - Returns 403 with specific error codes (PAGE_LIMIT_EXCEEDED, CODE_LIMIT_EXCEEDED, ANALYSES_EXHAUSTED)
  - Sets status=PENDING on creation
  - All endpoints require authentication and project ownership verification
  - Zod validation for all inputs
- Files changed:
  - app/src/app/api/projects/[pid]/analyses/route.ts (new) - POST and GET endpoints
- Learnings for future iterations:
  - Use $transaction for operations that need atomicity (decrement remaining + create analysis)
  - Report ref generation should handle collisions with retry + fallback to UUID approach
  - Return specific error codes in 403 responses to help UI display appropriate upgrade CTAs
  - Next.js 15+ uses [pid] pattern for nested dynamic routes
---

## Iteration 13 - US-013: Analysis Read and Delete
- What was implemented:
  - GET /api/analyses/:id - returns analysis detail with project info and finding count
  - GET /api/analyses/:id/findings - returns findings with pagination, filterable by category and status
  - GET /api/analyses/:id/report - returns full report payload with findings grouped by category, summary stats, confidence breakdown
  - DELETE /api/analyses/:id - removes analysis with cascade to findings and share tokens
  - All endpoints require authentication and verify ownership via project.user_id
  - Zod validation for all inputs including filter params
- Files changed:
  - app/src/app/api/analyses/[id]/route.ts (new) - GET detail and DELETE endpoints
  - app/src/app/api/analyses/[id]/findings/route.ts (new) - GET findings with filters
  - app/src/app/api/analyses/[id]/report/route.ts (new) - GET full report payload
- Learnings for future iterations:
  - Analysis ownership check goes through project relation (analysis.project.user_id)
  - For report endpoint, group findings by category using a simple reduce pattern
  - Prisma cascade on Analysis -> Findings and ShareTokens handles cleanup automatically
  - Filter params need explicit type casting for enum values in where clause
---

## Iteration 14 - US-014: Analysis Status Endpoint
- What was implemented:
  - GET /api/analyses/:id/status - lightweight polling endpoint for analysis progress
  - Returns only status-related fields: status, current_stage, compliance_score, overall_status, total_checks, started_at, completed_at, created_at
  - Minimal Prisma query using select to fetch only required fields (optimized for < 50ms)
  - Returns 404 for both "not found" and "not owned" cases (security best practice - don't leak existence)
  - UUID validation for analysis ID parameter
  - All endpoints require authentication
- Files changed:
  - app/src/app/api/analyses/[id]/status/route.ts (new) - Lightweight status endpoint
- Learnings for future iterations:
  - Use Prisma select to fetch only needed fields for performance-sensitive endpoints
  - Return same 404 error for both "not found" and "not owned" to prevent information leakage
  - Status endpoint pattern: minimal payload, single DB query, no nested relations except for ownership check
---

## Iteration 15 - US-015: File Upload with Tier Validation
- What was implemented:
  - POST /api/upload/presigned-url - generates presigned URL for S3-compatible storage (Railway Buckets)
  - Validates file type (PDF/PNG/JPG/TIFF only) via MIME type
  - Tier-based size limits: FREE <= 10MB, PRO <= 100MB
  - Returns upload_url, file_key, document_type, expires_in
  - POST /api/upload/confirm - verifies file exists in bucket, returns page count
  - Page count detection for PDFs via /Count or /N patterns in PDF trailer
  - Heuristic fallback for page count estimation (~75KB per page)
  - AWS Signature Version 4 signing for S3-compatible bucket access
  - File key ownership verification (uploads scoped to user ID prefix)
  - Added BUCKET_URL, BUCKET_ACCESS_KEY, BUCKET_SECRET_KEY, BUCKET_REGION env vars
- Files changed:
  - app/src/app/api/upload/presigned-url/route.ts (new) - Presigned URL generation endpoint
  - app/src/app/api/upload/confirm/route.ts (new) - Upload confirmation endpoint
  - app/.env.example (modified) - Added bucket configuration env vars
- Learnings for future iterations:
  - AWS Signature V4 requires specific header ordering and canonical request format
  - For PDF page count, /Count pattern in trailer is most reliable; /N is for linearized PDFs
  - Use Range header to fetch only PDF trailer (last 10KB) for page count detection
  - File key should include user ID prefix for ownership verification
  - Presigned URLs need content-type in signed headers for PUT operations
---

## Iteration 16 - US-016: Building Codes Public Endpoints
- What was implemented:
  - GET /api/regions - returns list of supported regions with flags (AU, UK, US)
  - GET /api/regions/:region/codes - returns ACTIVE codes for a region with requirement_count
  - Region metadata includes code, name, flag (emoji), and flag_url for SVG assets
  - Returns 404 for unknown regions (validates against AU, UK, US)
  - Only ACTIVE building codes are returned
  - requirement_count shows count of PUBLISHED requirements per code
  - Public endpoints - no authentication required
- Files changed:
  - app/src/app/api/regions/route.ts (new) - Regions list endpoint
  - app/src/app/api/regions/[region]/codes/route.ts (new) - Codes for region endpoint
- Learnings for future iterations:
  - Public endpoints don't need the requireAuth() helper
  - Use Prisma _count with where clause to count only PUBLISHED requirements
  - Region validation uses array includes() with uppercase normalization
---

## Iteration 17 - US-017: Code Request Endpoints
- What was implemented:
  - POST /api/code-requests - creates code request with SUBMITTED status
  - GET /api/code-requests - lists user's code requests with status and resolved code info
  - Validates code_name (required, max 255), region (AU/UK/US), description (optional, max 2000), reference_url (optional, valid URL)
  - Returns full request details including resolvedCode relation when available
  - Auth required for both endpoints
- Files changed:
  - app/src/app/api/code-requests/route.ts (new) - POST and GET endpoints
- Learnings for future iterations:
  - Zod v4 uses `message` instead of `errorMap` for custom error messages on enums
  - Use `z.enum(["A", "B"], { message: "..." })` for custom enum error messages
  - Include related records (like resolvedCode) in GET responses for better UX
---
